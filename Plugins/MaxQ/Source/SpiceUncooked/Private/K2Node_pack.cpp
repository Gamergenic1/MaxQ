// Copyright 2021 Gamergenic.  See full copyright notice in Spice.h.
// Author: chucknoble@gamergenic.com | https://www.gamergenic.com
// 
// Project page:   https://www.gamergenic.com/project/maxq/
// Documentation:  https://maxq.gamergenic.com/
// GitHub:         https://github.com/Gamergenic1/MaxQ/ 

#include "K2Node_pack.h"
#include "K2Utilities.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "ToolMenu.h"
#include "K2Node_CallFunction.h"
#include "SpiceK2.h"
#include "SpicePlatformDefs.h"
#include "K2SingleOutputOp.h"
//#include "EdGraphSchema_K2.h"
//#include "KismetCompiler.h"


#define LOCTEXT_NAMESPACE "K2Node_pack"


UK2Node_pack::UK2Node_pack(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack dimensionless vector", USpiceK2::vpack_vector, FK2Type::SDimensionlessVector() });
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack distance vector",  USpiceK2::vpack_vector, FK2Conversion::SDimensionlessVectorToSDistanceVector() });
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack velocity vector",  USpiceK2::vpack_vector, FK2Conversion::SDimensionlessVectorToSVelocityVector() });
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack angular velocity",  USpiceK2::vpack_vector, FK2Conversion::SDimensionlessVectorToSAngularVelocity() });
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack dimensionless state vector",  USpiceK2::vpack_state_vector, FK2Type::SDimensionlessStateVector() });
    SupportedOperations.Add(FK2SingleOutputOp{ "vpack state vector", USpiceK2::vpack_state_vector, FK2Conversion::SDimensionlessStateVectorToSStateVector() });

    for (const auto& op : SupportedOperations)
    {
        SupportedTypes.Add(op.OuterType);

#if WITH_EDITOR
        // Ensure the specified actions actually exist!
        if (!op.InnerToOuterConversion.ConversionName.IsNone())
        {
            check(USpiceK2::StaticClass()->FindFunctionByName(op.InnerToOuterConversion.ConversionName));
        }
        if (!op.K2NodeName.IsNone())
        {
            check(USpiceK2::StaticClass()->FindFunctionByName(op.K2NodeName));
        }
#endif
    }

    OutputPinName = "Vec";

    DefaultValues.Empty();
    for (int i = 0; i < USpiceK2::vpack_inputs_n; ++i)
    {
        DefaultValues.Add(0.);
    }
}



void UK2Node_pack::AllocateDefaultPins()
{
    Super::AllocateDefaultPins();

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

//    for (const auto& PinName : USpiceK2::vpack_inputs)
    for (int i = 0; i < USpiceK2::vpack_inputs_n; ++i)
    {
        const auto& PinName = USpiceK2::vpack_inputs[i];
        auto Pin { CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, FName(PinName)) };
        Pin->PinToolTip = TEXT("double precision input scalar");

        if(i < DefaultValues.Num())
        {
            K2Schema->SetPinAutogeneratedDefaultValue(Pin, FString::SanitizeFloat(DefaultValues[i]));
            Pin->DefaultValue = FString::SanitizeFloat(0.);
        }
    }

    auto PinCategory = UEdGraphSchema_K2::PC_Wildcard;
    if (!OperandType.Category.IsNone() && OperandType.Category != UEdGraphSchema_K2::PC_Wildcard)
    {
        PinCategory = OperandType.Category;
    }

    auto OutputPin = CreatePin(EGPD_Output, PinCategory, CreateUniquePinName(OutputPinName));
    if (!OperandType.Category.IsNone() && OperandType.Category != UEdGraphSchema_K2::PC_Wildcard)
    {
        OutputPin->PinType.PinCategory = OperandType.Category;
        OutputPin->PinType.PinSubCategoryObject = OperandType.SubCategoryObject;
        OutputPin->PinType.ContainerType = OperandType.Container;
    }

    OutputPin->PinToolTip = TEXT("packed vector");

    RefreshOperand();
}


void UK2Node_pack::ReconstructNode()
{
    Super::ReconstructNode();
}

void UK2Node_pack::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
    Super::ReallocatePinsDuringReconstruction(OldPins);
}

bool UK2Node_pack::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
    const auto& MyPinType = MyPin->PinType;
    const auto& OtherPinType = OtherPin->PinType;

    if (MyPin->Direction == EEdGraphPinDirection::EGPD_Input)
    {
        bool ConnectionOkay = OtherPinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard || OtherPinType.PinCategory == UEdGraphSchema_K2::PC_Double || OtherPinType.PinCategory == UEdGraphSchema_K2::PC_Real;

        if (!ConnectionOkay)
        {
            OutReason = TEXT("Input must be real");
        }
        return !ConnectionOkay;
    }

    bool FixedType = !OperandType.Category.IsNone() && OperandType.Category != UEdGraphSchema_K2::PC_Wildcard;

    if (FixedType && MyPin->Direction == EEdGraphPinDirection::EGPD_Output)
    {
        if (OperandType.Matches(OtherPinType)) return false;
        if (OtherPinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard) return false;

        OutReason = TEXT("Pin type must match exactly");
        return true; 
    }

    if (MyPinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
    {
        if(OtherPinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard) return false;
        
        for (int i = 0; i < SupportedTypes.Num(); ++i)
        {
            const auto& k2type = SupportedTypes[i];

            if (k2type.Matches(OtherPinType))
            {
                return false;
            }
        }
    }

    OutReason = TEXT("Pin connection type not supported");
    return true;
}


void UK2Node_pack::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
    Super::NotifyPinConnectionListChanged(Pin);
}

void UK2Node_pack::NodeConnectionListChanged()
{
    Super::NodeConnectionListChanged();

    bool NodeIsGeneric = true;
    bool bOperandChanged = false;
    FEdGraphPinType FoundType;

    // Determine if there are any connected pins that aren't wildcards.
    // And, if so, what type is it connected to?
    UEdGraphPin** ppOutputPin = Pins.FindByPredicate([](const UEdGraphPin* Pin) -> bool
        {
            return Pin->Direction == EEdGraphPinDirection::EGPD_Output;
        });

    if (!ppOutputPin)
    {
        return;
    }

    UEdGraphPin* OutputPin{ *ppOutputPin };

    for (UEdGraphPin* ConnectedPin : OutputPin->LinkedTo)
    {
        const auto& ConnectedPinType = ConnectedPin->PinType;

        if (ConnectedPinType.PinCategory != UEdGraphSchema_K2::PC_Wildcard)
        {
            NodeIsGeneric = false;
            FoundType = ConnectedPinType;
            break;
        }
    }

    if (NodeIsGeneric)
    {
        // Switch non-wildcard pin to wildcards.
        auto& PinType = OutputPin->PinType;

        bool bUpdatePin = PinType.PinCategory != UEdGraphSchema_K2::PC_Wildcard;
        bUpdatePin |= PinType.PinSubCategoryObject != nullptr;
        bUpdatePin |= PinType.ContainerType != EPinContainerType::None;

        bOperandChanged = !(OperandType == FK2Type::Wildcard());
        OperandType = FK2Type::Wildcard();

        if (bUpdatePin)
        {
            PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
            PinType.PinSubCategoryObject = nullptr;
            PinType.ContainerType = EPinContainerType::None;

            PinTypeChanged(OutputPin);
        }
    }
    else
    {
        // Find what supported operand type is connected...
        for (const auto& op : SupportedTypes)
        {
            if (op.Is(FoundType))
            {
                bOperandChanged = !(OperandType == op);
                OperandType = op;
                break;
            }
        }

        // Flip a generic pin to this type...
        auto& PinType = OutputPin->PinType;

        bool bUpdatePin = PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard;

        if (bUpdatePin)
        {
            PinType.PinCategory = OperandType.Category;
            PinType.PinSubCategoryObject = OperandType.SubCategoryObject;
            PinType.ContainerType = OperandType.Container;

            PinTypeChanged(OutputPin);
        }
    }

    RefreshOperand();
}

void UK2Node_pack::PinTypeChanged(UEdGraphPin* Pin)
{
    Super::PinTypeChanged(Pin);

    const auto& PinType { Pin->PinType };

    if (Pin->Direction == EEdGraphPinDirection::EGPD_Output)
    {
        // Update the tooltip
        for (const auto& Type : SupportedTypes)
        {
            if (Type.Is(PinType))
            {
                Pin->PinToolTip = FString::Printf(TEXT("Packed Vector (%s)"), *(Type.GetDisplayNameString()));
                break;
            }
        }

        // Notify any connections that this pin changed... which gives them the
        // opportunity to adapt, themselves...
        for (auto Connection : Pin->LinkedTo)
        {
            if (auto MathGeneric = Cast<IK2Node_MathGenericInterface>(Connection->GetOwningNode()))
            {
                MathGeneric->NotifyConnectionChanged(Connection, Pin);
            }
        }
    }
}


void UK2Node_pack::NotifyConnectionChanged(UEdGraphPin* Pin, UEdGraphPin* Connection)
{
    auto& PinType = Pin->PinType;
    auto& ConnectedPinType = Connection->PinType;

    // Only consider flipping if this type is a wildcard, but the other one isn't...
    if (PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard && ConnectedPinType.PinCategory != UEdGraphSchema_K2::PC_Wildcard)
    {
        NodeConnectionListChanged();
    }
}


bool UK2Node_pack::CheckForErrors(FKismetCompilerContext& CompilerContext, FK2SingleOutputOp& Operation)
{
    for (const auto& op : SupportedOperations)
    {
        if (op.OuterType == OperandType)
        {
            Operation = op;
            return false;
        }
    }

    CompilerContext.MessageLog.Error(*LOCTEXT("Error", "Node @@ had an operand type error.").ToString(), this);
    return true;
}

void UK2Node_pack::Serialize(FArchive& Ar)
{
    Super::Serialize(Ar);
}

void UK2Node_pack::PostLoad()
{
    Super::PostLoad();
}

void UK2Node_pack::PostPasteNode()
{
    Super::PostPasteNode();

//    RestoreStateMachineNode();
}


bool UK2Node_pack::IsActionFilteredOut(FBlueprintActionFilter const& Filter)
{
    return false;
}

FSlateIcon UK2Node_pack::GetIconAndTint(FLinearColor& OutColor) const
{
    OutColor = FColor::Emerald;
    return FSlateIcon("EditorStyle", "Kismet.AllClasses.FunctionIcon");
}

FLinearColor UK2Node_pack::GetNodeTitleColor() const
{
    return NodeBackgroundColor;
}


void UK2Node_pack::RefreshOperand()
{
    if (OperandType.SubCategoryObject.Get())
    {
        PinLabels.Empty();

        PinLabels = FK2Type::GetTypePinLabels(OperandType.SubCategoryObject.Get());
    }
    else
    {
        PinLabels.Empty();

        constexpr int NumberOfInputs = 3;

        for (int i = 0; i < NumberOfInputs; ++i)
        {
            PinLabels.Add(FString(USpiceK2::vpack_inputs[i]));
        }
    }

    bool visibilityChange = false;

    for (int i = 0; i < USpiceK2::vpack_inputs_n; ++i)
    {
        const auto& PinName = FName(USpiceK2::vpack_inputs[i]);
        auto Pin = FindPin(PinName);
        if (i < PinLabels.Num())
        {
#if WITH_EDITORONLY_DATA
            Pin->PinFriendlyName = FText::FromString(PinLabels[i]);
#endif
            visibilityChange |= Pin->bHidden;
            Pin->bHidden = false;
        }
        else
        {
            visibilityChange |= !Pin->bHidden;
            Pin->bHidden = true;
        }
    }

    if (visibilityChange)
    {
        GetGraph()->NotifyGraphChanged();
        FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
    }
    else
    {
        const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
        K2Schema->ForceVisualizationCacheClear();
    }
}

void UK2Node_pack::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    Super::ExpandNode(CompilerContext, SourceGraph);

    auto Schema = Cast< UEdGraphSchema_K2 >(GetSchema());

    FK2SingleOutputOp Operation;

    if (CheckForErrors(CompilerContext, Operation))
    {
        BreakAllNodeLinks();
        return;
    }

    UEdGraphPin** ppOutputPin = Pins.FindByPredicate([](const UEdGraphPin* Pin) -> bool
    {
        return Pin->Direction == EEdGraphPinDirection::EGPD_Output;
    });

    if (!ppOutputPin)
    {
        CompilerContext.MessageLog.Error(*LOCTEXT("Error", "Node @@ had an internal type error.").ToString(), this);
        BreakAllNodeLinks();
        return;
    }

    UEdGraphPin* OutputPin { *ppOutputPin };

    auto InternalNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
    InternalNode->FunctionReference.SetExternalMember(Operation.K2NodeName, USpiceK2::StaticClass());
    InternalNode->AllocateDefaultPins();
    CompilerContext.MessageLog.NotifyIntermediateObjectCreation(InternalNode, this);

    uint32 inputCount = 0;
    for(const auto& PinName : USpiceK2::vpack_inputs )
    {
        auto InputPin = FindPin(FName{PinName}, EEdGraphPinDirection::EGPD_Input);
        if (auto InternalPin = InternalNode->FindPin(FName{ PinName }, EEdGraphPinDirection::EGPD_Input))
        {
            MovePinLinksOrCopyDefaults(CompilerContext, InputPin, InternalPin);
            inputCount++;
        }
    }

//    ensure(inputCount == ComponentCounts[Operation.InnerType.TypeName]);

    auto InternalOut = InternalNode->GetReturnValuePin();

    if (!Operation.InnerToOuterConversion.ConversionName.IsNone())
    {
        auto ConversionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

        ConversionNode->FunctionReference.SetExternalMember(Operation.InnerToOuterConversion.ConversionName, USpiceK2::StaticClass());
        ConversionNode->AllocateDefaultPins();
        CompilerContext.MessageLog.NotifyIntermediateObjectCreation(ConversionNode, this);

        auto ConversionValueInput = ConversionNode->FindPinChecked(FName(USpiceK2::conv_input), EEdGraphPinDirection::EGPD_Input);
        auto ConversionOut = ConversionNode->GetReturnValuePin();

        Schema->TryCreateConnection(InternalOut, ConversionValueInput);
        MovePinLinksOrCopyDefaults(CompilerContext, OutputPin, ConversionOut);
    }
    else
    {
        MovePinLinksOrCopyDefaults(CompilerContext, OutputPin, InternalOut);
    }

    BreakAllNodeLinks();
}

void UK2Node_pack::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    RegisterAction(ActionRegistrar, GetClass());
}

FText UK2Node_pack::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    constexpr bool bUseShortNameForTitle{ true };

    switch (TitleType)
    {
    case ENodeTitleType::FullTitle:
        /** The full title, may be multiple lines. */
        return LOCTEXT("ListViewTitle", "vpack (experimental)");
        if (!bUseShortNameForTitle && !OperandType.TypeName.IsNone())
        {
            return FText::FromString(FString::Printf(TEXT("vpack %s"), *OperandType.TypeName.ToString()));
        }
        break;
    case ENodeTitleType::MenuTitle:
        /** Menu Title for context menus to be displayed in context menus referencing the node. */
        return LOCTEXT("MenuTitle", "vpack - Pack/Init MaxQ vector (experimental)");
    case ENodeTitleType::ListView:
        /** More concise, single line title. */
        return LOCTEXT("ListViewTitle", "vpack - Pack vector (experimental)");
    }

    return LOCTEXT("ShortTitle", "vpack");
}



FText UK2Node_pack::GetMenuCategory() const
{
    return LOCTEXT("Category", "MaxQ|Math|Vector");
}


FText UK2Node_pack::GetKeywords() const
{
    return LOCTEXT("Keywords", "VECTOR");
}


FText UK2Node_pack::GetTooltipText() const
{
    
    FText Tooltip = LOCTEXT("Tooltip", "Pack a MaxQ vector Type.\nStill experimental/under testing.\nThe intent is to support limited wildcards in a single action.\n\nSupports");

    FText ListStart = LOCTEXT("ListStart", ":\n");
    FText ListSItemeparator = LOCTEXT("ListItemSeparator", ",\n");
    bool bIsFirstItem = true;
    for (const FK2Type& Type : SupportedTypes)
    {
        Tooltip = Tooltip.Join(bIsFirstItem ? ListStart : ListSItemeparator, Tooltip, Type.GetDisplayNameText());
        bIsFirstItem = false;
    }

    return Tooltip;
}

#undef LOCTEXT_NAMESPACE