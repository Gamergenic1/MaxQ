// Copyright 2021 Gamergenic.  See full copyright notice in Spice.h.
// Author: chucknoble@gamergenic.com | https://www.gamergenic.com
// 
// Implementation of:
// "Adding Third-Party Libraries to Unreal Engine : NASA's SPICE Toolkit"
// https://gamedevtricks.com/post/third-party-libs-1/

#include "K2Node_bodvrd.h"
#include "K2Utilities.h"
#include "SpiceK2.h"

#include "EdGraphSchema_K2.h"

#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"


PRAGMA_PUSH_PLATFORM_DEFAULT_PACKING
extern "C"
{
#include "SpiceUsr.h"

// for ev2lin, dpspce
#include "SpiceZfc.h"
}
PRAGMA_POP_PLATFORM_DEFAULT_PACKING

using namespace ENodeTitleType;


#define LOCTEXT_NAMESPACE "K2Node_bodvrd"


UK2Node_bodvrd::UK2Node_bodvrd()
{
    OperationsMap.Add(WildcardOp().Final.TypeName, WildcardOp());
    OperationsMap.Add(DoubleOp().Final.TypeName, DoubleOp());
    OperationsMap.Add(ArrayDoubleOp().Final.TypeName, ArrayDoubleOp());
    OperationsMap.Add(SDimensionlessVectorOp().Final.TypeName, SDimensionlessVectorOp());
    
    OperationsMap.Add(SMassConstantOp().Final.TypeName, SMassConstantOp());
    OperationsMap.Add(SDistanceOp().Final.TypeName, SMassConstantOp());
    OperationsMap.Add(SDegreesOp().Final.TypeName, SMassConstantOp());
    OperationsMap.Add(SDistanceVectorOp().Final.TypeName, SMassConstantOp());
    OperationsMap.Add(SDistanceVectorOp().Final.TypeName, SMassConstantOp());

    for (auto kvp : OperationsMap)
    {
        auto newValue = kvp.Value;
        newValue.FullName = FText::FromString(newValue.ShortName.ToString() + "\nReturn value from the kernel pool");
        OperationsMap.Emplace(kvp.Key, newValue);
    }

    CurrentOperation = WildcardOp();
    CurrentOperation.FullName = FText::FromString(CurrentOperation.ShortName.ToString() + "\nReturn d.p. values from the kernel pool");
}

FText UK2Node_bodvrd::GetNodeTitle(Type TitleType) const
{
    switch (TitleType)
    {
    case FullTitle:
        /** The full title, may be multiple lines. */
        return CurrentOperation.FullName;
    case ListView:
        /** More concise, single line title. */
        return LOCTEXT("ListView", "bodvrd (read kernel pool)");
    case MenuTitle:
        /** Menu Title for context menus to be displayed in context menus referencing the node. */
        return LOCTEXT("MenuTitle", "bodvrd");
    }

    if (TitleType == EditableTitle)
    {
        FString title;
        
        if (!bodynm_Value.IsEmpty())
        {
            title += bodynm_Value;
        }
        else
        {
            title += "BODY";
        }

        title += "_";

        if (!item_Value.IsEmpty())
        {
            title += item_Value;
        }
        else
        {
            title += "ITEM";
        }
        
        /** Returns the editable title (which might not be a title at all). */
        return FText::FromString(title);
    }

    return LOCTEXT("bodvrd", "bodvrd");
}


FText UK2Node_bodvrd::GetMenuCategory() const
{
    return LOCTEXT("Category", "Spice|Api|Kernel");
}


FText UK2Node_bodvrd::GetKeywords() const
{
    return LOCTEXT("Keywords", "CONSTANTS");
}


FText UK2Node_bodvrd::GetTooltipText() const
{
    return LOCTEXT("Tooltip", "Fetch from the kernel pool the double precision values of an item associated with a body");
}


bool UK2Node_bodvrd::IsNodeSafeToIgnore() const {
    return true;
}


void UK2Node_bodvrd::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    RegisterAction(ActionRegistrar, GetClass());
}


void UK2Node_bodvrd::AllocateDefaultPins()
{
    Super::AllocateDefaultPins();

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

    // Exec pins - In
    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);

    // Exec out w/return values
    // Success - Exec
    UEdGraphPin* successPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, success_Field);
    successPin->PinToolTip = TEXT("Exit, if the action succeeds");

    // Success - return
    UEdGraphPin* OutputPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, value_Field);
    OutputPin->PinToolTip = "Kernal Value";

    // Error - Exec
    UEdGraphPin* errorPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, error_Field);
    errorPin->PinToolTip = TEXT("Exit, if the action fails");

    // Error - return
    UEdGraphPin* errorMessagePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_String, errorMessage_Field);
    errorMessagePin->PinToolTip = TEXT("An error message, if the action fails");

    // Inputs - Body/Item
    UEdGraphPin* bodyPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, bodynm_Field);
    K2Schema->SetPinAutogeneratedDefaultValue(bodyPin, bodynm_Value);
    bodyPin->PinToolTip = TEXT("Body name");
    bodyPin->DefaultValue = bodynm_DefaultValue.ToString();

    UEdGraphPin * itemPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, item_Field);
    K2Schema->SetPinAutogeneratedDefaultValue(itemPin, item_Value);
    itemPin->PinToolTip = TEXT("Item for which values are desired. (\"RADII\", \"NUT_PREC_ANGLES\", etc.)");
    itemPin->DefaultValue = item_DefaultValue.ToString();

}

void UK2Node_bodvrd::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
    Super::NotifyPinConnectionListChanged(Pin);

    if (Pin == returnValuePin())
    {
//        Pin->PinFriendlyName = FText::GetEmpty();

        FEdGraphPinType& ReturnValuePinType = Pin->PinType;

        ReturnValuePinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
        ReturnValuePinType.PinSubCategory = NAME_None;
        ReturnValuePinType.PinSubCategoryObject = nullptr;

        if (Pin->LinkedTo.Num() == 1)
        {
            const FEdGraphPinType& ConnectedPinType = Pin->LinkedTo[0]->PinType;

            for (auto kvp : OperationsMap)
            {
                if (kvp.Value.Final.Matches(ConnectedPinType))
                {
                    CurrentOperation = kvp.Value;

                    ReturnValuePinType.PinCategory = CurrentOperation.Final.Category;
                    ReturnValuePinType.PinSubCategoryObject = CurrentOperation.Final.SubCategoryObject;
  //                  Pin->PinFriendlyName = FText::FromName(CurrentOperation.Final.TypeName);

                    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
                    K2Schema->ForceVisualizationCacheClear();
                    return;
                }
            }
        }
        CurrentOperation = WildcardOp();
        const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
        K2Schema->ForceVisualizationCacheClear();
    }
}

void UK2Node_bodvrd::ReconstructNode()
{
    Super::ReconstructNode();

    if (returnValuePin()->LinkedTo.Num() != 1)
    {
        CurrentOperation = WildcardOp();
    }
}

void UK2Node_bodvrd::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    Super::ExpandNode(CompilerContext, SourceGraph);

    auto Schema = Cast< UEdGraphSchema_K2 >(GetSchema());

    if (CheckForErrors(CompilerContext))
    {
        BreakAllNodeLinks();
        return;
    }


    FName BodvrdFunctionName;
    FName ConvFunctionName = "";

    auto returnValue = returnValuePin();
    UEdGraphPin* link = nullptr;

    if (returnValue->LinkedTo.Num() == 1)
    {
        link = returnValue->LinkedTo[0];

        auto pinType = link->PinType;

        bool found = true;
        for (auto kvp : OperationsMap)
        {
            if (kvp.Value.Final.Matches(pinType))
            {
                CurrentOperation = kvp.Value;
                link->PinType.PinCategory = CurrentOperation.Final.Category;
                link->PinType.PinSubCategoryObject = CurrentOperation.Final.SubCategoryObject;
            }
        }

        if (!found)
        {
            CompilerContext.MessageLog.Error(*LOCTEXT("Error", "Node @@ return value link is not supported.").ToString(), this);
            BreakAllNodeLinks();
            return;
        }

        BodvrdFunctionName = CurrentOperation.K2NodeName;
        ConvFunctionName = CurrentOperation.Conversion.ConversionName;
    }
    else
    {
        // no output link, let's run the node anyways... and make it a double
        BodvrdFunctionName = GET_FUNCTION_NAME_CHECKED(USpiceK2, bodvrd_double_K2);
    }


    auto InternalNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
    InternalNode->FunctionReference.SetExternalMember(BodvrdFunctionName, USpiceK2::StaticClass());
    InternalNode->AllocateDefaultPins();

    CompilerContext.MessageLog.NotifyIntermediateObjectCreation(InternalNode, this);

    if(link){
        // Wire the return value up first... it may need to go through a type converter
        if (ConvFunctionName != "")
        {
            auto ConversionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
            ConversionNode->FunctionReference.SetExternalMember(ConvFunctionName, USpiceK2::StaticClass());
            ConversionNode->AllocateDefaultPins();

            CompilerContext.MessageLog.NotifyIntermediateObjectCreation(ConversionNode, this);

            auto internalReturn = getReturnValuePin(InternalNode);
            auto conversionInput = InternalNode->FindPinChecked(value_Field);
            auto conversionReturn = getReturnValuePin(ConversionNode);
            auto myReturn = returnValuePin();

            Schema->TryCreateConnection(internalReturn, conversionInput);
            MovePinLinksOrCopyDefaults(CompilerContext, internalReturn, conversionInput);

            Schema->TryCreateConnection(conversionReturn, myReturn);
            MovePinLinksOrCopyDefaults(CompilerContext, conversionReturn, myReturn);
        }
        else
        {
            auto internalReturn = getReturnValuePin(InternalNode);
            auto myReturn = returnValuePin();

            Schema->TryCreateConnection(myReturn, internalReturn);
            MovePinLinksOrCopyDefaults(CompilerContext, myReturn, internalReturn);
        }
    }

 
    // Now the body and item pins...
    auto thisBodynm = bodynmPin();   auto thatBodynm = InternalNode->FindPinChecked(bodynm_Field);
    auto thisItem = itemPin();   auto thatItem = InternalNode->FindPinChecked(item_Field);

    Schema->TryCreateConnection(thisBodynm, thatBodynm);
    MovePinLinksOrCopyDefaults(CompilerContext, thisBodynm, thatBodynm);

    Schema->TryCreateConnection(thisItem, thatItem);
    MovePinLinksOrCopyDefaults(CompilerContext, thisItem, thatItem);

    // Exec nodes....
    UEdGraphPin* NodeExec = GetExecPin();
    UEdGraphPin* NodeSuccess = successPin();
    UEdGraphPin* NodeError = errorPin();

    UEdGraphPin* InternalExec = InternalNode->GetExecPin();
    Schema->TryCreateConnection(NodeExec, InternalExec);
    MovePinLinksOrCopyDefaults(CompilerContext, NodeExec, InternalExec);

    UEdGraphPin* InternalSuccess = InternalNode->FindPinChecked(success_Field);
    check(InternalSuccess != nullptr);
    Schema->TryCreateConnection(NodeSuccess, InternalSuccess);
    MovePinLinksOrCopyDefaults(CompilerContext, NodeSuccess, InternalSuccess);

    UEdGraphPin* InternalError = InternalNode->FindPinChecked(error_Field);
    check(InternalError != nullptr);
    Schema->TryCreateConnection(NodeError, InternalError);
    MovePinLinksOrCopyDefaults(CompilerContext, NodeError, InternalError);

    UEdGraphPin* InternalNodeErrorMessage = InternalNode->FindPinChecked(errorMessage_Field);
    Schema->TryCreateConnection(errorMessagePin(), InternalNodeErrorMessage);
    MovePinLinksOrCopyDefaults(CompilerContext, errorMessagePin(), InternalNodeErrorMessage);

    BreakAllNodeLinks();
}


bool UK2Node_bodvrd::CheckForErrors(FKismetCompilerContext& CompilerContext)
{
    bool bError = false;

    if (false)
    {
        CompilerContext.MessageLog.Error(*LOCTEXT("Error", "Node @@ had an input error.").ToString(), this);
        bError = true;
    }

    return bError;
}


bool UK2Node_bodvrd::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
    if (OtherPin)
    {
        if ((MyPin->Direction == EGPD_Output) && (MyPin->GetName() == returnValuePin()->GetName()))
        {
            bool compatible = IsOutputCompatible(OtherPin);

            if (!compatible)
            {
                OutReason = LOCTEXT("TypeDisallowed", "Pin does not match a supported type").ToString();
                return true;
            }
        }
    }

    return Super::IsConnectionDisallowed(MyPin, OtherPin, OutReason);
}

bool UK2Node_bodvrd::IsOutputCompatible(const UEdGraphPin* ThePin) const
{
    if (ThePin)
    {
        // Loop through our operations and try to find a match
        auto pinType = ThePin->PinType;

        for (auto kvp : OperationsMap)
        {
            if (kvp.Value.Final.Matches(pinType))
                return true;
        }
    }

    return false;
}

UEdGraphPin* UK2Node_bodvrd::getReturnValuePin(UK2Node_CallFunction* other) const
{
    return other->GetReturnValuePin();
}


SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::WildcardOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd"), FName("bodvrd_double_K2"), FK2Type::Wildcard());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::DoubleOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd Double"), FName("bodvrd_double_K2"), FK2Type::Double());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::ArrayDoubleOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd Array(Double)"), FName("bodvrd_array_K2"), FK2Type::DoubleArray());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SDimensionlessVectorOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SDimensionlessVector"), FName("bodvrd_vector_K2"), FK2Type::SDimensionlessVector());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SMassConstantOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SMassConstant"), FName("bodvrd_double_K2"), FK2Conversion::DoubleToSMassConstant());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SDistanceOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SDistance"), FName("bodvrd_double_K2"), FK2Conversion::DoubleToSDistance());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SDegreesOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SAngle(Degrees)"), FName("bodvrd_double_K2"), FK2Conversion::DegreesToSAngle());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SDistanceVectorOp()
{

    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SDistanceVector"), FName("bodvrd_vector_K2"), FK2Conversion::SDimensionlessVectorToSDistanceVector());
    return v;
}

SPICEUNCOOKED_API FK2OperationNOutput UK2Node_bodvrd::SVelocityVectorOp()
{
    static auto v = FK2OperationNOutput(FText::FromString("bodvrd SVelocityVector"), FName("bodvrd_vector_K2"), FK2Conversion::SDimensionlessVectorToSVelocityVector());
    return v;
}



#undef LOCTEXT_NAMESPACE